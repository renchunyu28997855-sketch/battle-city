export class Renderer {
    private ctx: CanvasRenderingContext2D;
    private palette: Record<string, string>;

    constructor(canvas: HTMLCanvasElement) {
        this.ctx = canvas.getContext('2d')!;
        this.palette = {
            black: '#000000',
            white: '#FFFFFF',
            red: '#E74C3C',        // 更柔和的红
            green: '#2ECC71',      // 更现代的绿
            blue: '#3498DB',       // 更现代的蓝
            gray: '#95A5A6',
            darkGray: '#34495E',
            lightGray: '#BDC3C7',
            yellow: '#F1C40F',
            cyan: '#1ABC9C',
            magenta: '#9B59B6',
            orange: '#E67E22',
            steel: '#708090'       // 钢灰色
        };
    }

    clear(): void {
        // 高清化：渐变灰色背景
        const gradient = this.ctx.createLinearGradient(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        gradient.addColorStop(0, '#4a5568');
        gradient.addColorStop(1, '#2d3748');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }

    drawRect(x: number, y: number, width: number, height: number, color: string): void {
        this.ctx.fillStyle = this.palette[color] || color;
        this.ctx.fillRect(x, y, width, height);
    }

    drawSprite(x: number, y: number, width: number, height: number, color: string): void {
        this.drawRect(x, y, width, height, color);
    }

    drawTank(x: number, y: number, size: number, direction: string, color: string = 'green'): void {
        const ctx = this.ctx;
        const mainColor = this.palette[color] || color;
        
        ctx.save();

        // 1. 履带 (Tracks) - 增加细节刻画
        ctx.fillStyle = '#2c3e50'; // 履带底色
        const trackWidth = size * 0.2;
        const trackHeight = size;
        
        // 左履带
        ctx.fillRect(x, y, trackWidth, trackHeight);
        // 右履带
        ctx.fillRect(x + size - trackWidth, y, trackWidth, trackHeight);

        // 履带纹理 (横条)
        ctx.fillStyle = '#1a252f';
        const segments = 8;
        for(let i=0; i<segments; i++) {
            const segY = y + (i * (size/segments));
            ctx.fillRect(x, segY + 2, trackWidth, 1);
            ctx.fillRect(x + size - trackWidth, segY + 2, trackWidth, 1);
        }

        // 2. 车身 (Body) - 带倒角的方块
        const bodyPad = size * 0.15;
        ctx.fillStyle = mainColor;
        // 主体
        ctx.fillRect(x + bodyPad, y + bodyPad, size - bodyPad*2, size - bodyPad*2);
        
        // 车身隆起部分 (更有立体感)
        ctx.fillStyle = 'rgba(255,255,255,0.2)'; // 高光层
        ctx.fillRect(x + bodyPad + 2, y + bodyPad + 2, size - bodyPad*2 - 4, size/2);
        
        // 3. 炮塔 (Turret)
        const turretSize = size * 0.35;
        const tx = x + size/2;
        const ty = y + size/2;
        
        // 炮管 (Barrel)
        ctx.fillStyle = '#95a5a6'; // 银灰色炮管
        ctx.strokeStyle = '#7f8c8d';
        const barrelLen = size * 0.55;
        const barrelW = size * 0.12;
        
        ctx.beginPath();
        if (direction === 'up') ctx.rect(tx - barrelW/2, ty - barrelLen, barrelW, barrelLen);
        else if (direction === 'down') ctx.rect(tx - barrelW/2, ty, barrelW, barrelLen);
        else if (direction === 'left') ctx.rect(tx - barrelLen, ty - barrelW/2, barrelLen, barrelW);
        else if (direction === 'right') ctx.rect(tx, ty - barrelW/2, barrelLen, barrelW);
        ctx.fill();
        ctx.stroke();
        
        // 炮管末端黑色开口
        ctx.fillStyle = '#000';
        const muzzleLen = 4;
        ctx.beginPath();
        if (direction === 'up') ctx.rect(tx - barrelW/2, ty - barrelLen, barrelW, muzzleLen);
        else if (direction === 'down') ctx.rect(tx - barrelW/2, ty + barrelLen - muzzleLen, barrelW, muzzleLen);
        else if (direction === 'left') ctx.rect(tx - barrelLen, ty - barrelW/2, muzzleLen, barrelW);
        else if (direction === 'right') ctx.rect(tx + barrelLen - muzzleLen, ty - barrelW/2, muzzleLen, barrelW);
        ctx.fill();

        // 炮塔主体 (圆形带圈)
        ctx.fillStyle = mainColor;
        ctx.beginPath();
        ctx.arc(tx, ty, turretSize, 0, Math.PI * 2);
        ctx.fill();
        
        // 炮塔顶盖细节
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.arc(tx, ty, turretSize * 0.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    drawBrick(x: number, y: number, size: number): void {
        // 高清化：更好的砖块渲染
        const ctx = this.ctx;
        
        // 绘制基础背景
        ctx.fillStyle = '#5a5a5a';
        ctx.fillRect(x, y, size, size);
        
        // 高清化砖块：2x2布局
        const gap = 1;
        const rows = 2;
        const cols = 2;
        const bW = (size - gap * (cols - 1)) / cols;
        const bH = (size - gap * (rows - 1)) / rows;
        
        // 经典的红色砖块颜色
        const brickColors = [
            '#C0392B',  // 深红
            '#E74C3C',  // 红
            '#D32F2F',  // 深红
            '#C62828'   // 非常深红
        ];
        
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const bx = x + c * (bW + gap);
                const by = y + r * (bH + gap);
                const color = brickColors[(r + c) % brickColors.length];
                
                // 绘制砖块主体
                ctx.fillStyle = color;
                ctx.fillRect(bx, by, bW, bH);
                
                // 绘制砖块阴影和高光（模拟3D效果）
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.fillRect(bx, by, bW, bH * 0.3); // 顶部高光
                
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(bx, by + bH - bH * 0.3, bW, bH * 0.3); // 底部阴影
            }
        }
    }

    drawSteel(x: number, y: number, size: number): void {
        const ctx = this.ctx;
        
        // 高清化：更好的钢铁渲染
        ctx.fillStyle = '#555555'; // 基础灰
        ctx.fillRect(x, y, size, size);
        
        // 金属底色
        ctx.fillStyle = '#B0BEC5'; // 浅灰蓝
        ctx.fillRect(x + 2, y + 2, size - 4, size - 4);
        
        // 内部细节
        ctx.fillStyle = '#78909C'; // 深灰蓝
        ctx.fillRect(x + 6, y + 6, size - 12, size - 12);
        
        // 经典的X形交叉线（反光）
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = Math.max(2, size / 32); // 根据大小自适应
        ctx.moveTo(x + size * 0.1, y + size * 0.1);
        ctx.lineTo(x + size * 0.9, y + size * 0.9);
        ctx.moveTo(x + size * 0.9, y + size * 0.1);
        ctx.lineTo(x + size * 0.1, y + size * 0.9);
        ctx.stroke();
        
        // 铆钉
        ctx.fillStyle = '#607D8B';
        const dotSize = Math.max(2, size / 32);
        ctx.fillRect(x + 4, y + 4, dotSize, dotSize); // 左上
        ctx.fillRect(x + size - 4 - dotSize, y + 4, dotSize, dotSize); // 右上
        ctx.fillRect(x + 4, y + size - 4 - dotSize, dotSize, dotSize); // 左下
        ctx.fillRect(x + size - 4 - dotSize, y + size - 4 - dotSize, dotSize, dotSize); // 右下
    }

    drawWater(x: number, y: number, size: number): void {
        const ctx = this.ctx;
        
        // 绘制基础背景
        ctx.fillStyle = '#555555';
        ctx.fillRect(x, y, size, size);
        
        // 底色
        ctx.fillStyle = '#3498DB';
        ctx.fillRect(x, y, size, size);

        // 波纹效果
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        
        // 画三条波浪线
        for (let i = 1; i <= 3; i++) {
            const yOffset = y + (size / 4) * i;
            ctx.beginPath();
            ctx.moveTo(x, yOffset);
            // 贝塞尔曲线模拟波浪
            ctx.bezierCurveTo(
                x + size / 3, yOffset - 5, 
                x + size * 2 / 3, yOffset + 5, 
                x + size, yOffset
            );
            ctx.stroke();
        }
    }

    drawForest(x: number, y: number, size: number): void {
        const ctx = this.ctx;
        
        ctx.fillStyle = '#555555';
        ctx.fillRect(x, y, size, size);
        
        // 绘制茂密的树叶簇
        const leafSize = size / 3;
        const positions = [
            {x: 0.2, y: 0.2}, {x: 0.8, y: 0.2}, 
            {x: 0.5, y: 0.5}, 
            {x: 0.2, y: 0.8}, {x: 0.8, y: 0.8},
            {x: 0.1, y: 0.5}, {x: 0.9, y: 0.5}, {x: 0.5, y: 0.1}, {x: 0.5, y: 0.9}
        ];

        // 两种绿色交替
        positions.forEach((pos, index) => {
            ctx.fillStyle = index % 2 === 0 ? '#27AE60' : '#2ECC71'; 
            ctx.beginPath();
            ctx.arc(x + pos.x * size, y + pos.y * size, leafSize, 0, Math.PI*2);
            ctx.fill();
        });

        // 中心的深色阴影，增加层次
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath();
        ctx.arc(x + size/2, y + size/2, size/4, 0, Math.PI*2);
        ctx.fill();
    }
    
    drawIce(x: number, y: number, size: number): void {
        const ctx = this.ctx;
        
        ctx.fillStyle = '#555555';
        ctx.fillRect(x, y, size, size);
        
        // 冰面底色 - 浅蓝色
        ctx.fillStyle = 'rgba(173, 216, 230, 0.6)';
        ctx.fillRect(x + 2, y + 2, size - 4, size - 4);
        
        // 冰面反光线条
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.moveTo(x + 5, y + size - 8);
        ctx.lineTo(x + size - 8, y + 5);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(x + 10, y + size - 4);
        ctx.lineTo(x + size - 4, y + 10);
        ctx.stroke();
    }

    drawFloor(x: number, y: number, size: number): void {
        const ctx = this.ctx;
        
        // 1. 修改底色：使用 solid gray #555555
        ctx.fillStyle = '#555555'; 
        ctx.fillRect(x, y, size, size);
    }

    drawBase(x: number, y: number, size: number): void {
        this.drawEagle(x, y, size); // 复用 Eagle 绘制逻辑，或者你可以单独写
        // 简单的外墙保护示意
        // 这里仅仅是标识基地位置，如果需要画墙，应该由 Map 数据决定调用 drawBrick
    }

    drawEagle(x: number, y: number, size: number): void {
        const ctx = this.ctx;
        const cx = x + size / 2;
        const cy = y + size / 2;

        // 1. 灰色底座
        ctx.fillStyle = '#7F8C8D';
        ctx.fillRect(x, y, size, size);
        
        // 2. 徽章背景 (深蓝色盾牌)
        ctx.fillStyle = '#2C3E50';
        ctx.beginPath();
        ctx.moveTo(x + 2, y + 2);
        ctx.lineTo(x + size - 2, y + 2);
        ctx.lineTo(x + size - 2, y + size * 0.7);
        ctx.lineTo(cx, y + size - 2);
        ctx.lineTo(x + 2, y + size * 0.7);
        ctx.closePath();
        ctx.fill();

        // 3. 几何化老鹰 (金色) - 简化为几何图形以适应小尺寸
        ctx.fillStyle = '#F1C40F'; // 金色
        
        // 翅膀
        ctx.beginPath();
        ctx.moveTo(cx, cy + size * 0.2);
        ctx.lineTo(x + 4, cy - size * 0.2); // 左翼尖
        ctx.lineTo(x + size - 4, cy - size * 0.2); // 右翼尖
        ctx.fill();

        // 身体和头
        ctx.beginPath();
        ctx.ellipse(cx, cy - size * 0.1, size * 0.15, size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // 眼睛
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(cx - 2, cy - size * 0.15, 1, 0, Math.PI * 2); // 左眼
        ctx.arc(cx + 2, cy - size * 0.15, 1, 0, Math.PI * 2); // 右眼
        ctx.fill();
    }

    drawText(text: string, x: number, y: number, color: string = 'white', fontSize: number = 24): void {
        const ctx = this.ctx;
        ctx.fillStyle = this.palette[color] || color;
        // 添加文字阴影，更有游戏感
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        ctx.font = `bold ${fontSize}px "Courier New", monospace`; // 使用等宽字体更有复古感
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x, y);

        // 重置阴影
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }

    drawHeart(x: number, y: number, size: number = 20): void {
        const ctx = this.ctx;
        ctx.fillStyle = '#E74C3C';
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 5;
        
        ctx.beginPath();
        const topCurveHeight = size * 0.3;
        ctx.moveTo(x + size / 2, y + size / 5);
        ctx.bezierCurveTo(
          x + size / 2, y, 
          x, y, 
          x, y + topCurveHeight
        );
        ctx.bezierCurveTo(
          x, y + (size + topCurveHeight) / 2, 
          x + size / 2, y + (size + topCurveHeight) / 2, 
          x + size / 2, y + size
        );
        ctx.bezierCurveTo(
          x + size, y + (size + topCurveHeight) / 2, 
          x + size, y + (size + topCurveHeight) / 2, 
          x + size, y + size
        );
        ctx.bezierCurveTo(
          x + size, y + topCurveHeight, 
          x + size / 2, y, 
          x + size / 2, y + size / 5
        );
        ctx.fill();
        
        ctx.shadowColor = 'transparent';
    }
    
